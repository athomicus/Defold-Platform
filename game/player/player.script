-- constant variables that won't change throughout play
local MOVE_SPEED = 100
local GRAVITY = -500
local MAX_FALL_SPEED = 500
local JUMP_SPEED = 300
local NORMAL_THRESHOLD = 0.8

-- pre-hashing improves performance
local MOVE_LEFT_INPUT = hash("move_left")
local MOVE_RIGHT_INPUT = hash("move_right")
local JUMP_INPUT = hash("jump")

local IDLE_ANIM = hash("player_idle")
local MOVE_ANIM = hash("player_move")
local JUMP_ANIM = hash("player_jump")

local CONTACT_POINT_RESPONSE = hash("contact_point_response")
local GROUND_LAYER = hash("ground")

local INCREASE_SCORE = hash("increase_score")

function init (self)
	-- post messages
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_camera_projection")
	msg.post("@render:", "clear_color", { color = vmath.vector4(0.5, 0.8, 0.9, 1) })

	-- define variables
	self.spawn_position = go.get_position()
	self.velocity = vmath.vector3()
	self.facing_direction = 1
	self.correction = vmath.vector3()
	self.ground_contact = true
	self.anim = nil
	self.score = 0
end

-- returns value clamped between the min and max
local function clamp (value, min, max)
	if value < min then
		return min
	elseif value > max then
		return max
	else
		return value
	end
end

local function play_animation (self, anim)
	-- only play if it's not our current animation
	if self.anim ~= anim then
		sprite.play_flipbook("#sprite", anim)
		self.anim = anim
	end
end

local function update_animations (self)
	-- set facing direction
	sprite.set_hflip("#sprite", self.facing_direction == 1)

	-- playing animations based on conditions
	if self.ground_contact == false then
		play_animation(self, JUMP_ANIM)
	elseif self.velocity.x == 0 then
		play_animation(self, IDLE_ANIM)
	else
		play_animation(self, MOVE_ANIM)
	end
end

function fixed_update (self, dt)
	-- gravity
	self.velocity.y = self.velocity.y + GRAVITY * dt
	self.velocity.y = clamp(self.velocity.y, -MAX_FALL_SPEED, MAX_FALL_SPEED)
	
	-- movement
	local pos = go.get_position()
	pos = pos + self.velocity * dt
	go.set_position(pos)

	-- animations
	update_animations(self)

	-- reset state variables
	self.correction = vmath.vector3()
	self.ground_contact = false

	-- check if we have fallen off the map
	if pos.y < -100 then
		msg.post("game_controller:/gc#game_controller", "reload_level")
	end
end

local function handle_obstacle_contact (self, normal, distance)
	-- position compensation
	if distance > 0 then
		local proj = vmath.project(self.correction, normal * distance)
		if proj < 1 then
			local comp = (distance - distance * proj) * normal
			go.set_position(go.get_position() + comp)
			self.correction = self.correction + comp
		end
	end

	-- wall collision
	if math.abs(normal.x) > NORMAL_THRESHOLD then
		self.velocity.x = 0
	end

	-- ground collision
	if normal.y > NORMAL_THRESHOLD then
		self.velocity.y = 0
		self.ground_contact = true
	end

	-- ceiling collision
	if normal.y < -NORMAL_THRESHOLD then
		self.velocity.y = 0
	end
end

function on_message (self, message_id, message, sender)
	-- sent when we collide with something
	if message_id == CONTACT_POINT_RESPONSE then
		if message.group == GROUND_LAYER then
			handle_obstacle_contact(self, message.normal, message.distance)
		end
	-- sent when we pickup a coin
	elseif message_id == INCREASE_SCORE then
		self.score = self.score + message.amount
		msg.post("#player_hud", "update_score_text", { score = self.score })
		sound.play("#sound_coin")
	end
end

local function move (self, direction)
	-- if moving, update our facing direction
	if direction ~= 0 then
		self.facing_direction = direction
	end
	
	self.velocity.x = MOVE_SPEED * direction
end

local function jump (self)
	-- return if we're not on the ground
	if self.ground_contact == false then
		return
	end

	self.velocity.y = JUMP_SPEED
	self.ground_contact = false

	sound.play("#sound_jump")
end

function on_input (self, action_id, action)
	if action_id == MOVE_LEFT_INPUT then
		move(self, -action.value)
	elseif action_id == MOVE_RIGHT_INPUT then
		move(self, action.value)
	end

	if action_id == JUMP_INPUT then
		jump(self)
	end
end




